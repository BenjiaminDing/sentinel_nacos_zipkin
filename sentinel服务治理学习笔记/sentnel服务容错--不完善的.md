![流控sentinel每秒钟最多2个请求](D:\音乐图片\typora图片\image-20220319100850178.png)

![每秒钟超过2次请求被流控](D:/音乐图片/typora图片/image-20220319101205209.png)



## 容错的==三个核心==思想

01保证自己不被上游服务压垮，02保证自己不被下游服务拖垮，03保证外界环境良好

可以在上游进行==限流==，保护中间的核心服务；对于下游服务，核心服务的请求一直没有回应可能被拖垮，可以使用==熔断降级==；



```

```

Sentinel的主要功能就是容错，主要体现为下面这三个：

::flags::流量控制
流量控制在网络传输中是一个常用的概念，它用于调整网络包的数据。任意时间到来的请求往往是
随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。
Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状。可以做一个漏斗限制==最大流量==

::flags::熔断降级
当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则
对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致==级联故障==。

Sentinel 对这个问题采取了两种手段:
::flags::M1--通过并发线程数进行限制
Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。当某个资源
出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆
积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的
线程完成任务后才开始继续接收请求。

::flags:M2:--通过响应时间对资源进行降级
除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。
当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的
时间窗口之后才重新恢复。

==Sentinel 和 Hystrix 的区别==
两者的原则是一致的, 都是当一个资源出现问题时, 让其快速失败, 不要波及到其它服务
但是在限制的手段上, 确采取了完全不一样的方法:
Hystrix 采用的是==线程池隔离==的方式, 优点是做到了资源之间的隔离, 缺点是增加了线程
切换的成本。
Sentinel 采用的是通过并发线程的数量和响应时间来对资源做限制。
系统负载保护
 Sentinel 同时提供系统维度的自适应保护能力。当系统负载较高的时候，如果还持续让
请求进入可能会导致系统崩溃，无法响应。在集群环境下，会把本应这台机器承载的流量转发到其
它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，Sentinel 提供了对应的保
护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请
求。
总之一句话: 我们需要做的事情，就是在Sentinel的资源上配置各种各样的规则，来实现各种容错的功
能。



## 流控规则中的关联

<img src="D:/音乐图片/typora图片/image-20220319111053946.png" alt="image-20220319111053946" style="zoom: 80%;" />

流控模式---关联，

适合用于让步，举例指定资源的一个查询接口，和指定资源的一个编辑接口，一般设置编辑接口message2的qps=3，则如果qps=5大于3，那么新增的接口message1会被流控限流   提示 ：Blocked by Sentinel (flow limiting)  



链路是指更详细的---未解决





## 服务降级

<img src="D:/音乐图片/typora图片/image-20220320183754621.png" alt="image-20220320183754621" style="zoom:80%;" />

当平均响应时间RT大于1ms，就进入准降级状态，接下来一秒内连续5个请求都是RT>1MS就就降级，10秒后恢复正常状态。

==##关于熔断和降级对比==

```
服务熔断：
熔断机制是应对雪崩效应的一种微服务链路保护机制。

假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的**“雪崩效应”**。

高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。

服务降级：
在高并发的情况下， 防止用户一直阻塞等待，采用限流/熔断方法，使用服务降级的方式返回一个友好的提示给客户端，不会执行业务逻辑请求，直接走本地的fallback的方法。

提示语：当前排队人数过多，稍后重试~

7.2.服务熔断与降级区别：
相同点：

1）目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；

2）最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；

3）自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；

不同点：

1）触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；

2）管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）

3）实现方式不太一样；服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为自我熔断。
————————————————
版权声明：本文为CSDN博主「小牧要学习」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/muhaokai/article/details/119342412
```

