:flags:

## 4.7 @SentinelResource的使用

:factory: 

将限流和降级方法外置到单独的类中

![01](D:/音乐图片/typora图片/image-20220602124118193.png)



![02](D:/音乐图片/typora图片/image-20220602124132788.png)



## 4.8 Sentinel规则持久化

```
解决的问题就是，在dashboard配置降级规则，每次重启服务器都会clear为null,所以将配置的信息保存到服务器的一个位置即使再次启动服务器，也会读取到之前对该接口配置的 降级规则，更人性化
```



![03](D:/音乐图片/typora图片/image-20220602125301057.png)

```
上图是 在创建FilePersistence.java的的文件扫描位置指定 cn.com.benjiamin.shoporder.config.FilePersistence
```

![4](D:/音乐图片/typora图片/image-20220602124518667.png)

```
上图4是持久化配置信息的逻辑，jiang信息保存到硬盘的操作，实现一个框架的接口
下图5就是我在FilePersistence类指定 保存降级规则的文件是json格式的数据
```

![5](D:/音乐图片/typora图片/image-20220602124802367.png)

## 4.9 Feign整合Sentinel

```txt
配置文件需要做配置修改，开启feign对sentinel的支持
```

![6](D:/音乐图片/typora图片/image-20220529230640264.png)



![7](D:/音乐图片/typora图片/image-20220529230727047.png)

```
图7是可以判定 ，order在调用service-product时候出现错误才被拦截进入 这个ProductServiceFallback类， 做出相应的处理
```



![8](D:/音乐图片/typora图片/image-20220602130845330.png)

```

扩展: 如果想在容错类中拿到具体的错误,可以使用下面的方式
ProductServiceFallback不能打印出具体的错误信息，使用 ProductServiceFallbackFactory解决这个问题
```





## ==第五章Gateway--服务网关==





:flags:

众多微服务的缺点

```
这样的架构，会存在着诸多的问题：
客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性
认证复杂，每个服务都需要独立认证。
存在跨域请求，在一定场景下处理相对复杂。
```

网关来解决这些问题

```
第一步创建微服务api-gateway
第二步添加依赖
比较重要的是在application.yml中添加spring.main.web-application-type=reactive  剔除出网关和tomcat的关系
```

![w1](D:/音乐图片/typora图片/image-20220602201956833.png)

 ![w2](D:/音乐图片/typora图片/image-20220602201853818.png)

![w3](D:/音乐图片/typora图片/image-20220602202223664.png)



​     ==使用上图w3的方式或者使用下面排除web内置容器的方式，建议使用下面这个方式更容易理解==

```
     == 使用上图w3的方式或者使用下面排除web内置容器的方式，建议使用下面这个方式更容易理解==
      
      <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <!-- Maven整个生命周期内排除内置容器，排除内置容器导出成war包可以让外部容器运行spring-boot项目-->
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        
```

下面是application.yml的内容

```yml
server:
  port: 7000
spring:
  application:
    name: api-gateway
    
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 # 将gateway注册到nacos
        #7-10将当前api-gateway注册到nacos注册中心
    gateway:
      discovery:
        locator:
          enabled: true  #让gateway从nacos获取服务信息
          
      routes:
        - id: product_route
          uri: lb://service-product    #lb指的是负载均衡
#          uri: http://127.0.0.1:8081
          order: 1
          predicates:          #断言判断条件
            - Path=/product-serv/**
            - Before=2022-11-28T00:00:00.000+08:00 #限制请求时间在2019-11-28之前
            - Method=GET
            - Weight=group3, 1
          filters:
            - StripPrefix=1
            #id就是路由到几个微服务
        - id: order_route
          uri: lb://shop-order
#          uri: http://127.0.0.1:8091
          order: 1
          predicates:
            - Path=/order-serv/**
            - Weight=group3, 9
          filters:
            - StripPrefix=1
#     spring.main.web-application-type=reactive  是提出网关和tomcat的关系
#  main:
#    web-application-type: reactive
```

![w4](C:/Users/22166/AppData/Roaming/Typora/typora-user-images/image-20221013224619228.png)

:black_flag:==网关断言使用==

```
SpringCloud Gateway包括许多内置的断言工厂，所有这些断言都与HTTP请求的不同属性匹配。具体
如下：
基于Datetime类型的断言工厂
此类型的断言根据时间做判断，主要有三个：
AfterRoutePredicateFactory： 接收一个日期参数，判断请求日期是否晚于指定日期
BeforeRoutePredicateFactory： 接收一个日期参数，判断请求日期是否早于指定日期
BetweenRoutePredicateFactory： 接收两个日期参数，判断请求日期是否在指定时间段内
-After=2019-12-31T23:59:59.789+08:00[Asia/Shanghai]

基于远程地址的断言工厂 RemoteAddrRoutePredicateFactory：接收一个IP地址段，判断请求主
机地址是否在地址段中
-RemoteAddr=192.168.1.1/24

基于Cookie的断言工厂
CookieRoutePredicateFactory：接收两个参数，cookie 名字和一个正则表达式。 判断请求
cookie是否具有给定名称且值与正则表达式匹配。
-Cookie=chocolate, ch.
基于Header的断言工厂
HeaderRoutePredicateFactory：接收两个参数，标题名称和正则表达式。 判断请求Header是否
具有给定名称且值与正则表达式匹配。
-Header=X-Request-Id, \d+
基于Host的断言工厂
HostRoutePredicateFactory：接收一个参数，主机名模式。判断请求的Host是否满足匹配规则。
-Host=**.testhost.org
基于Method请求方法的断言工厂
MethodRoutePredicateFactory：接收一个参数，判断请求类型是否跟指定的类型匹配。
-Method=GET
基于Path请求路径的断言工厂
PathRoutePredicateFactory：接收一个参数，判断请求的URI部分是否满足路径规则。
-Path=/foo/{segment}
基于Query请求参数的断言工厂
QueryRoutePredicateFactory ：接收两个参数，请求param和正则表达式， 判断请求参数是否具
有给定名称且值与正则表达式匹配。
-Query=baz, ba.
基于路由权重的断言工厂
WeightRoutePredicateFactory：接收一个[组名,权重], 然后对于同一个组内的路由按照权重转发
routes:
-id: weight_route1 uri: host1 predicates:
-Path=/product/**
-Weight=group3, 1
-id: weight_route2 uri: host2 predicates:
-Path=/product/**
-Weight= group3, 9
```

==断言测试无效原因不明==

![image-20221014181923785](C:/Users/22166/AppData/Roaming/Typora/typora-user-images/image-20221014181923785.png)

自定义断言,案例对age进行自定义访问参数年纪的范围

![w5](D:/音乐图片/typora图片/image-20220602232423992.png)

自定义一个断言处理类

![w6](D:/音乐图片/typora图片/image-20220602232621643.png)

但是参数的参数必须在路径后面，不能在请求体里面，原因目前不知:question::question:

![w7](D:/音乐图片/typora图片/image-20220602232719256.png)



## 过滤器

![image-20221014201113979](C:/Users/22166/AppData/Roaming/Typora/typora-user-images/image-20221014201113979.png)

内置过滤器

![w8](D:/音乐图片/typora图片/image-20220602235437204.png)

![w9](D:/音乐图片/typora图片/image-20220602235404407.png)

自定义局部过滤器

![w10](D:/音乐图片/typora图片/image-20220603100302853.png)

![w11](D:/音乐图片/typora图片/image-20220603100244839.png)

==全局过滤器== 鉴权



全局过滤器作用于所有路由, 无需配置。通过全局过滤器可以实现对权限的统一校验，安全性验证等功 能。

![w12](D:/音乐图片/typora图片/image-20220603100530851.png)

```
这里说明下，上图中的123步骤生成token返回给前端，这里就不进行编写了。后续有时间进行编写
```

![w13](D:/音乐图片/typora图片/image-20220603105126287.png)

![w14](D:/音乐图片/typora图片/image-20220603105141148.png)

![w15](D:/音乐图片/typora图片/image-20220603105245057.png)



##==网关限流限流降级==



从1.6.0版本开始，Sentinel提供了SpringCloud Gateway的适配模块，可以提供两种资源维度的限流： route维度：即在Spring配置文件中配置的路由条目，资源名为对应的routeId 自定义API维度：用户可以利用Sentinel提供的API来自定义一些API分组

![w16](D:/音乐图片/typora图片/image-20220603193222557.png)

![w17](D:/音乐图片/typora图片/image-20220603193356648.png)





83/140