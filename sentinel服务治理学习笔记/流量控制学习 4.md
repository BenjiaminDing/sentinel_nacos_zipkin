如果是下面的提示多半是没有启动nameserver

```

org.springframework.messaging.MessagingException: No route info of this topic, test-topic-1
See http://rocketmq.apache.org/docs/faq/ for further details.; nested exception is org.apache.rocketmq.client.exception.MQClientException: No route info of this topic, test-topic-1
See http://rocketmq.apache.org/docs/faq/ for further details.
```

如果是下面的提示--可能是防火墙没有关闭---由于每次重启虚拟机防火墙都会再次开启 （systemctl stop firewalld）

```
org.springframework.messaging.MessagingException: Send [3] times, still failed, cost [6282]ms, Topic: test-topic-1, BrokersSent: [bennode2, bennode2, bennode2]
See http://rocketmq.apache.org/docs/faq/ for further details.; nested exception is org.apache.rocketmq.client.exception.MQClientException: Send [3] times, still failed, cost [6282]ms, Topic: test-topic-1, BrokersSent: [bennode2, bennode2, bennode2]
See http://rocketmq.apache.org/docs/faq/ for further details.
```

7.5.1  普通消息

01 可靠同步发送、

```
可靠同步发送
同步发送是指消息发送方发出数据后，会在收到接收方发回响应之后才发下一个数据包的通讯方
式。
此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。
可靠异步发送
异步发送是指发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。发送
方通过回调接口接收服务器响应，并对响应结果进行处理。
异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知
启动转码服务，转码完成后通知推送转码结果等。
单向发送
单向发送是指发送方只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不
等待应答。
适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集
```



```
        SendResult sendResult =
                rocketMQTemplate.syncSend("test-topic-1", "这是一条同步消息",10000);
        System.out.println(sendResult);
```

可以可以再rocketmq--dashboard 控制台看到相关信息

![image-20221023100342546](../../AppData/Roaming/Typora/typora-user-images/image-20221023100342546.png)

![image-20221023100349019](../../AppData/Roaming/Typora/typora-user-images/image-20221023100349019.png)







7.5.2 顺序消息

由于普通消息m1,m2,m3 再消息投递的时候，可能进入不同的message queue中，消费者可以随机消费消息，

保证投递的消息到同一个message queue里面就是按顺序的



![image-20221023112608585](../../AppData/Roaming/Typora/typora-user-images/image-20221023112608585.png)





![image-20221023112838431](../../AppData/Roaming/Typora/typora-user-images/image-20221023112838431.png)



使用syncSendOrderly方法就可以将一次5条消息，添加到一个message queue上面，解决普通消息的问题

```
    @Test
    public void testSyncSendOrderly() {
//第三个参数用于队列的选择
        for (int i = 0; i <5; i++) {
            rocketMQTemplate.syncSendOrderly("test-topic-1", "这是一条异步顺序消息",
                    "xx");
        }

    }
```



7.5.3 事务消息 

RocketMQ提供了事务消息，通过事务消息就能达到分布式事务的最终一致

![image-20221023114712611](../../AppData/Roaming/Typora/typora-user-images/image-20221023114712611.png)

两个概念: 半事务消息：暂不能投递的消息，发送方已经成功地将消息发送到了RocketMQ服务端，但是服务 端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的 消息即半事务消息。 消息回查：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失， RocketMQ服务端通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该 消息的最终状态（Commit 或是 Rollback），该询问过程即消息回查













---



注解 @RocketMQMessageListener(的使用

![image-20221023135114541](../../AppData/Roaming/Typora/typora-user-images/image-20221023135114541.png)



RocketMQ支持两种消息模式: 

广播消费: 每个消费者实例都会收到消息,也就是一条消息可以被每个消费者实例处理； 集群消费: 一条消息只能被一个消费者实例消费

如果是集群一个消费者先消费，其他消费者就无法再消费了